---
layout: default
---
<script type="text/javascript">


window.addEventListener("load", windowLoadHandler, false);

function windowLoadHandler() {
  canvasApp();
}

function canvasSupport() {
  //TODO
  return true;
}

function canvasApp() {
  if (!canvasSupport()) {
    return;
  }

  var displayCanvas = document.createElement('canvas');
  displayCanvas.id = 'displayCanvas';
  displayCanvas.width = 100;
  displayCanvas.height = 100;
  displayCanvas.style.width = '100vw';
  displayCanvas.style.height = '100vh';
  displayCanvas.style.opacity = '0.2';
  displayCanvas.style.zIndex = '-1';
  displayCanvas.style.position = 'absolute';
  displayCanvas.style.top = 0;

  document.body.appendChild(displayCanvas);

  var context = displayCanvas.getContext("2d");
  var displayWidth = displayCanvas.width;
  var displayHeight = displayCanvas.height;

  var cellList;
  var gridWidth;
  var gridHeight;
  var cellHeight;
  var cellWidth;
  var timer;

  ///////////////////////
  //for speed, defining variables used in update function as global variables.
  var i;
  var cell;
  var rAve;
  var rVelAve;
  var ease;
  var rv,mag;
  var rAccel;
  var rSep;
  var velMax;
  var minDist;
  var minDistSquare;
  var dr;
  var neighbor;
  var neighborPointer;
  var f;
  var sepMagRecip;
  var sepNormMag;

  ///////////////////////

  init();

  function init() {
    gridWidth = 60;
    gridHeight = 36;

    cellWidth = displayWidth/gridWidth;
    cellHeight = displayHeight/gridHeight;

    ease = 0.27;
    velMax = 255;
    minDist = 8;
    minDistSquare = minDist*minDist;
    sepNormMag = 4;

    createCells();

    timer = window.setInterval(onTimer, 1000/30);
  }

  function createCells() {
    var i,j;
    var r;
    var cellArray = [];
    cellList = {};
    for (i = 0; i < gridWidth; i++) {
      cellArray.push([]);
      for (j = 0; j < gridHeight; j++) {
        var initialBrightness = 0.9;
        var remainder = 1 / (1 - initialBrightness);
        r = 255 * 0.9 + (Math.random() * 255 / remainder);
        var newCell = {
          x: i*displayWidth/gridWidth,
          y: j*displayHeight/gridHeight,
          r: r,
          bufferR: r,
          rVel: 0,
          bufferRVel: 0,
          neighbors: [],
          neighborPointerList: {}
        }

        //set neighbors
        if (i > 0) {
          newCell.neighbors.push(cellArray[i-1][j]);
          cellArray[i-1][j].neighbors.push(newCell);
        }
        if (j > 0) {
          newCell.neighbors.push(cellArray[i][j-1]);
          cellArray[i][j-1].neighbors.push(newCell);
        }

        //store cells in a 2D array only for the sake of setting neighbors
        cellArray[i].push(newCell);

        //store cells in a more efficient linked list, for use in update loop
        if ((i == 0) && (j == 0)) {
          cellList.first = newCell;
        }
        else {
          newCell.next = cellList.first;
          cellList.first = newCell;
        }
      }
    }

    //convert neighbor arrays to linked lists - linked list just has pointer objects.
    var cell = cellList.first;
    var numNeighbors;
    while (cell != null) {
      numNeighbors = 1;
      cell.neighborPointerList.first = {};
      cell.neighborPointerList.first.neighbor = cell.neighbors[0];
      for (i = 1; i < cell.neighbors.length; i++) {
        var newPointer = {};
        newPointer.next = cell.neighborPointerList.first;
        cell.neighborPointerList.first = newPointer;
        newPointer.neighbor = cell.neighbors[i];
        ++numNeighbors;
      }
      cell.numNeighbors = numNeighbors;
      cell = cell.next;
    }
  }

  function onTimer(evt) {
    cell = cellList.first;
    while (cell != null) {
      rAve = 0;
      rVelAve = 0;
      rSep = 0;
      neighborPointer = cell.neighborPointerList.first;
      while (neighborPointer != null) {
        neighbor = neighborPointer.neighbor;
        rAve += neighbor.r;
        rVelAve += neighbor.rVel;
        dr = cell.r - neighbor.r;
        if (dr*dr < minDistSquare) {
          rSep += dr;
        }
        neighborPointer = neighborPointer.next;
      }

      rAve *= (f = 1/cell.numNeighbors);
      rVelAve *= f;

      //normalize separation vector
      if (rSep != 0) {
        rSep *= (sepMagRecip = sepNormMag/Math.sqrt(rSep*rSep));
      }

      //Update velocity by combining separation, alignment and cohesion effects. Change velocity only by 'ease' ratio.
      cell.bufferRVel += ease*(rSep + rVelAve + rAve - cell.r - cell.bufferRVel);

      //update colors according to color velocities
      cell.bufferR += cell.bufferRVel;

      //bounce colors off of color cube boundaries
      if (cell.bufferR < 0) {
        cell.bufferR = 0;
        cell.bufferRVel *= -1;
      }
      else if (cell.bufferR > 255) {
        cell.bufferR = 255;
        cell.bufferRVel *= -1;
      }

      cell = cell.next;
    }

    //now loop through again, copy buffer values and draw
    cell = cellList.first;
    while (cell != null) {
      cell.r = cell.bufferR;
      cell.rVel = cell.bufferRVel;
      context.fillStyle = "rgb(" + ~~cell.r + "," + ~~cell.r + "," + ~~cell.r +")";
      context.fillRect(cell.x, cell.y, cellWidth, cellHeight);

      cell = cell.next;
    }
  }
}
</script>

<style>
  body {
    font-family: monospace;
  }
  ul {
    font-size: calc(1em + 1vw);
  }

  li {
    list-style: none;
    margin-bottom: 18px;
  }

  .node:before,
  .node:after {
    color: #aaa;
  }

  .node:before {
    content: '<';
  }

  .node:after {
    content: ' />';
  }

  .comment {
    color: #888;
    font-size: 0.6em;
    display: block;
    margin-left: 1em;
  }

  .comment:before {
    content: '<!--';
  }

  .comment:after {
    content: '-->';
  }
</style>

<div>
<h2>Index</h2>
<ul>
  <li>
    <a class="node" href="/vue-chess">Chess</a>
    <small class="node comment">
      Web chess with offline support &amp; push notifications
    </small>
  </li>
  <li>
    <a class="node" href="/vue-chess">Transport</a>
    <small class="node comment">
      Melbourne Public Transport timetable
    </small>
  </li>
  <li>
    <a class="node" href="/talks">Talks</a>
    <small class="node comment">
      Actually slides. But they typically accompany talks
    </small>
  </li>
</ul>
</div>
